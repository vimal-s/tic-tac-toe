{"version":3,"sources":["components/Board.js","components/Game.js","index.js"],"names":["Square","props","className","onClick","style","shouldHighlight","background","undefined","value","Board","i","this","winningIndices","includes","squares","board","row","startIndex","j","push","renderSquare","React","Component","calculateWinner","length","a","b","c","Game","state","history","Array","fill","markedIndex","xIsNext","currentBoardIndex","squareIndex","newHistory","slice","newSquares","setState","concat","step","showLatest","map","currHistory","index","coordinate","parseInt","message","id","fontWeight","jumpTo","status","handleClick","getMoves","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.2f8cf3bd.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nfunction Square(props) {\r\n  return (\r\n    <button\r\n      className=\"square\"\r\n      onClick={props.onClick}\r\n      style={props.shouldHighlight ? { background: \"red\" } : undefined}\r\n    >\r\n      {props.value}\r\n    </button>\r\n  );\r\n}\r\n\r\nclass Board extends React.Component {\r\n  renderSquare(i) {\r\n    let shouldHighlight =\r\n      this.props.winningIndices && this.props.winningIndices.includes(i);\r\n\r\n    return (\r\n      <Square\r\n        shouldHighlight={shouldHighlight}\r\n        value={this.props.squares[i]}\r\n        onClick={() => this.props.onClick(i)}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    let board = [];\r\n    for (let i = 0; i < 3; i++) {\r\n      let row = [];\r\n      let startIndex = i * 3;\r\n      for (let j = startIndex; j < startIndex + 3; j++) {\r\n        row.push(this.renderSquare(j));\r\n      }\r\n\r\n      board.push(<div className=\"board-row\">{row}</div>);\r\n    }\r\n\r\n    return <div>{board}</div>;\r\n  }\r\n}\r\n\r\nexport default Board;\r\n","import React from \"react\";\r\nimport Board from \"./Board.js\";\r\n\r\nfunction calculateWinner(squares) {\r\n  let winningIndices = [\r\n    [0, 1, 2],\r\n    [3, 4, 5],\r\n    [6, 7, 8],\r\n    [0, 3, 6],\r\n    [1, 4, 7],\r\n    [2, 5, 8],\r\n    [0, 4, 8],\r\n    [2, 4, 6],\r\n  ];\r\n  for (let i = 0; i < winningIndices.length; i++) {\r\n    const [a, b, c] = winningIndices[i];\r\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n      return [a, b, c];\r\n    }\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      history: [\r\n        {\r\n          squares: Array(9).fill(null),\r\n          markedIndex: null,\r\n        },\r\n      ],\r\n      xIsNext: true, // 'X' is the first player\r\n      currentBoardIndex: 0,\r\n    };\r\n  }\r\n\r\n  handleClick(squareIndex) {\r\n    const currentBoardIndex = this.state.currentBoardIndex;\r\n    const newHistory = this.state.history.slice(0, currentBoardIndex + 1);\r\n\r\n    if (\r\n      newHistory[currentBoardIndex].squares[squareIndex] ||\r\n      calculateWinner(newHistory[currentBoardIndex].squares)\r\n    ) {\r\n      // do not proceed further. Because either square is already used or winner is found.\r\n      return;\r\n    }\r\n\r\n    // todo: why slice here, why not working without slice strange behaviour\r\n    // i think this has to do with rendering in react may.....be...\r\n    const newSquares = newHistory[currentBoardIndex].squares.slice();\r\n\r\n    newSquares[squareIndex] = this.state.xIsNext ? \"X\" : \"O\";\r\n    this.setState({\r\n      // todo: see if you want to keep previous history\r\n      // one idea is to use array of array instead of array for the state history\r\n      history: newHistory.concat([\r\n        { squares: newSquares, markedIndex: squareIndex },\r\n      ]),\r\n      currentBoardIndex: currentBoardIndex + 1,\r\n      xIsNext: !this.state.xIsNext,\r\n    });\r\n  }\r\n\r\n  jumpTo(step) {\r\n    this.setState({\r\n      currentBoardIndex: step,\r\n      xIsNext: step % 2 === 0 ? true : false,\r\n    });\r\n  }\r\n\r\n  getMoves() {\r\n    let history = this.state.history;\r\n\r\n    // only show the latest move when player is not already on it\r\n    let showLatest;\r\n    if (history.length > this.state.currentBoardIndex + 1) {\r\n      showLatest = true;\r\n    } else {\r\n      history = history.slice(0, history.length - 1);\r\n    }\r\n\r\n    return history.map((currHistory, index) => {\r\n      // todo: make this a separate function\r\n      let coordinate =\r\n        \"(\" +\r\n        parseInt(currHistory.markedIndex / 3, 10) +\r\n        \",\" +\r\n        (currHistory.markedIndex % 3) +\r\n        \")\";\r\n\r\n      // todo: make this a separate function\r\n      let message = \"Go back to start\";\r\n      if (index !== 0) {\r\n        message = \"Go back to move: \" + index + \", coord: \" + coordinate;\r\n        if (showLatest && index === history.length - 1) {\r\n          message = \"Go to latest move: \" + index + \", coord: \" + coordinate;\r\n        }\r\n      }\r\n\r\n      return (\r\n        <li key={message}>\r\n          <button\r\n            className=\"game-moves\"\r\n            id={index}\r\n            style={{\r\n              // borderRadius: \"5px\",\r\n              // last element is always bold but it's fine cause element is not shown on screen\r\n              fontWeight:\r\n                index === this.state.currentBoardIndex ? \"bold\" : \"normal\",\r\n            }}\r\n            onClick={() => this.jumpTo(index)}\r\n          >\r\n            {message}\r\n          </button>\r\n        </li>\r\n      );\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const currentBoardIndex = this.state.currentBoardIndex;\r\n    const squares = this.state.history[currentBoardIndex].squares;\r\n    const winningIndices = calculateWinner(squares);\r\n\r\n    let status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\");\r\n    if (winningIndices) {\r\n      status = \"Winner: \" + squares[winningIndices[0]];\r\n    } else if (currentBoardIndex === 9) {\r\n      // to keep it simple we are only checking for when board gets full\r\n      status = \"Match Draw\";\r\n    }\r\n\r\n    return (\r\n      <div className=\"game\">\r\n        <div className=\"game-board\">\r\n          <Board\r\n            winningIndices={winningIndices}\r\n            squares={squares}\r\n            onClick={(squareIndex) => this.handleClick(squareIndex)}\r\n          />\r\n        </div>\r\n        <div className=\"game-info\">\r\n          <div>{status}</div>\r\n          <ul>{this.getMoves()}</ul>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Game;\r\n","import ReactDOM from \"react-dom\";\r\nimport Game from \"./components/Game\";\r\nimport \"./index.css\";\r\n\r\nReactDOM.render(<Game />, document.getElementById(\"root\"));\r\n"],"sourceRoot":""}